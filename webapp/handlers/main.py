#  handlers/main.py  - kla app main webapp request handlers
#
#
__author__ = 'johnw'

import logging, json

from flask import (Flask, request, session, g, redirect, url_for,
     abort, render_template)

import settings

log = logging.getLogger('handlers.main')

# instantiate Flask (global) app
kla = Flask('app', **settings.FLASK.app)

def run_dev_server():
    "launch Flask dev server"
    kla.run(**settings.FLASK.run)

# -------- main request handlers --------

parser = None
nodeData = {}

@kla.route('/')
def index():
    #
    #  test parseTree
    from parser.parse import Parser
    from parser.patterns.clientLog import patternDef
    import os
    #
    global parser, nodeData
    parser = Parser(os.path.expanduser("~/Dropbox/Documents/Kontiki 2014/debugging/Lloyds/pDPTu3_AT2k1-20151125-204429/error2.log"), patternDef)
    parser.parse()
    #

    def _getLabels(child):
        return nodeData[child["id"]]["labels"]

    def _getRows(child):
        return nodeData[child["id"]]["rows"]

    def _mergeTableData(child, labelIndexes, labels, rows):
        "merges child labels & row into parent labels & rows"
        childLabels, childRows = _getLabels(child), _getRows(child)
        newLabels = set(childLabels) - set(labels)
        for k in sorted(newLabels):
            labelIndexes[k] = len(labels)
            labels.append(k)
        row = [''] * (len(labels))
        for i, k in enumerate(childLabels):
            row[labelIndexes[k]] = childRows[0][i]
        rows.append(row)

    def _renderParseTree(name, level, path):
        "recursive parseTree-to-jsTree data renderer"
        labelIndexes = dict(timestamp=0, threadID=1, threadName=2, module=3)
        children, labels, row, rows = [], ["timestamp", "threadID", "threadName", "module"], ['', '', '', ''], []
        metaPath = path.strip('.')
        if isinstance(level, dict):
            # first pass for leaf values
            rows = [row]
            keys = set(level.keys())
            for k in sorted(keys):
                v = level[k]
                if isinstance(v, (dict, list)):
                    continue
                else:
                    if k in labelIndexes:
                        row[labelIndexes[k]] = v
                    else:
                        labelIndexes[k] = len(labels)
                        labels.append(k)
                        row.append(v)
                    keys.remove(k)
            # second pass for non-leafs
            for k in sorted(keys):
                v = level[k]
                child = _renderParseTree(k, v, path + '.' + k)
                if len(row) == 0 and len(_getRows(child)) == 1:
                    # no leaf-values at this level, accumulate any immediate child singleton rows into my row vector
                    rows = []
                    _mergeTableData(child, labelIndexes, labels, rows)
                children.append(child)
            #
        else: # list
            for i, v in enumerate(level):
                # list top-level values always dicts
                elementPath = "%s.%03d" % (path, i)
                label = parser.nodeMeta.get(elementPath.strip('.') + ".index", v.get('timestamp'))
                child = _renderParseTree(label, v, elementPath)
                if len(_getRows(child)) == 1:
                    # no leaf-values at this level, accumulate any immediate child singleton rows into my row vector
                    _mergeTableData(child, labelIndexes, labels, rows)
                children.append(child)

        # build node for this level
        id = "n_%d" % len(nodeData)
        node = dict(text=name, id=id)
        if children:
            node['children'] = children
        # extract line bounds from node metadata
        startLineNo, endLineNo = parser.nodeMeta.get(metaPath + ".startLineNo", 0), parser.nodeMeta.get(metaPath + "endLineNo", 0)
        # startLineNo = min(row[0] for row in rows)
        # endLineNo = max(row[1] for row in rows)
        # # strip line-no fields  todo: there has to be a cleaner way than this, make lineNo metadata some side structure perhaps??
        # labels = labels[2:]
        # rows = [row[2:] for row in rows]
        # save table data in side dict for later ajax calls
        nodeData[id] = dict(labels=labels, rows=rows, startLineNo=startLineNo, endLineNo=endLineNo)
        #
        return node

    # top-level jsTree roots are children of the top-level parseTree
    renderedTree = _renderParseTree('top', parser.parseTree, '')['children']

    return render_template("index.html",
                           renderedParseTree=json.dumps(renderedTree))

# jsTree data format
#     'core' : {
#         'data' : [
#                 {
#                   id          : "string" // will be autogenerated if omitted
#                   text        : "string" // node text
#                   icon        : "string" // string for custom
#                   state       : {
#                     opened    : boolean  // is the node open
#                     disabled  : boolean  // is the node disabled
#                     selected  : boolean  // is the node selected
#                   },
#                   children    : []  // array of strings or objects
#                   li_attr     : {}  // attributes for the generated LI node
#                   a_attr      : {}  // attributes for the generated A node
#                 }#         ]
#     }
# });

@kla.route('/node/<nodeID>')
def nodeDataTable(nodeID):
    "ajax call for table data for IDed node"
    nd = nodeData.get(nodeID, dict(labels=[], rows=[], startLineNo=0, endLineNo=0))
    return render_template("node_table.html",
                           upperFirst=lambda x: x[0].upper() + x[1:],
                           **nd)

@kla.route('/log')
def getLog():
    "returns current client log as plain text"
    return '<pre id="log-pre" style="font-size:10px">' + parser.log + '</pre>'


