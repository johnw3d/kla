#  handlers/main.py  - kla app main webapp request handlers
#
#
__author__ = 'johnw'

import logging, json

from flask import (Flask, request, session, g, redirect, url_for,
     abort, render_template)

import settings

log = logging.getLogger('handlers.main')

# instantiate Flask (global) app
kla = Flask('app', **settings.FLASK.app)

def run_dev_server():
    "launch Flask dev server"
    kla.run(**settings.FLASK.run)

# -------- main request handlers --------

parser = None
nodeData = {}

@kla.route('/')
def index():
    #
    #  test parseTree
    from parser.parse import Parser
    from parser.patterns.clientLog import patternDef
    import os
    #
    global parser, nodeData
    parser = Parser(os.path.expanduser("~/Dropbox/Documents/Kontiki 2014/debugging/Lloyds/pDPTu3_AT2k1-20151125-204429/error2.log"), patternDef)
    parser.parse()
    #

    def _getLabels(child):
        return nodeData[child["id"]]["labels"]

    def _getRows(child):
        return nodeData[child["id"]]["rows"]

    def _mergeTableData(child, labelIndexes, labels, rows):
        "merges child labels & row into parent labels & rows"
        childLabels, childRows = _getLabels(child), _getRows(child)
        newLabels = set(childLabels) - set(labels)
        for k in sorted(newLabels):
            labelIndexes[k] = len(labels)
            labels.append(k)
        row = [''] * len(labels)
        for i, k in enumerate(childLabels):
            row[labelIndexes[k]] = childRows[0][i]
        rows.append(row)

    def _renderParseTree(name, level):
        "recursive parseTree-to-jsTree data renderer"
        labelIndexes = {}
        children, labels, row = [], [], []
        rows = [row]
        if isinstance(level, dict):
            # first pass for leaf values
            keys = set(level.keys())
            for k in sorted(keys):
                v = level[k]
                if isinstance(v, (dict, list)):
                    continue
                else:
                    labelIndexes[k] = len(labels)
                    labels.append(k)
                    row.append(v)
                    keys.remove(k)
            # second pass for non-leafs
            for k in sorted(keys):
                v = level[k]
                child = _renderParseTree(k, v)
                if len(row) == 0 and len(_getRows(child)) == 1:
                    # no leaf-values at this level, accumulate any immediate child singleton rows into my row vector
                    _mergeTableData(child, labelIndexes, labels, rows)
                children.append(child)
            #
        else: # list
            for v in level:
                # list top-level values always dicts
                timestamp = v.get('timestamp')
                child = _renderParseTree(timestamp, v)
                if len(_getRows(child)) == 1:
                    # no leaf-values at this level, accumulate any immediate child singleton rows into my row vector
                    _mergeTableData(child, labelIndexes, labels, rows)
                children.append(child)

        # build node for this level
        id = "n_%d" % len(nodeData)
        node = dict(text=name, id=id)
        if children:
            node['children'] = children
        # save table data in side dict for later ajax calls
        nodeData[id] = dict(labels=labels, rows=rows)
        #
        return node

    # top-level jsTree roots are children of the top-level parseTree
    renderedTree = _renderParseTree('top', parser.parseTree)['children']

    return render_template("index.html",
                           renderedParseTree=json.dumps(renderedTree))

# jsTree data format
#     'core' : {
#         'data' : [
#                 {
#                   id          : "string" // will be autogenerated if omitted
#                   text        : "string" // node text
#                   icon        : "string" // string for custom
#                   state       : {
#                     opened    : boolean  // is the node open
#                     disabled  : boolean  // is the node disabled
#                     selected  : boolean  // is the node selected
#                   },
#                   children    : []  // array of strings or objects
#                   li_attr     : {}  // attributes for the generated LI node
#                   a_attr      : {}  // attributes for the generated A node
#                 }#         ]
#     }
# });

@kla.route('/node/<nodeID>')
def nodeDataTable(nodeID):
    "ajax call for table data for IDed node"
    nd = nodeData.get(nodeID, dict(labels=[], rows=[]))
    return render_template("node_table.html", labels=nd["labels"], rows=nd["rows"])
